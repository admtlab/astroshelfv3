// Generated by CoffeeScript 1.4.0
var WebGL,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

WebGL = (function() {

  WebGL.gl = 0;

  WebGL.shaderProgram = 0;

  WebGL.mvMatrix = 0;

  WebGL.mvMatrixStack = null;

  WebGL.pMatrix = 0;

  function WebGL(options) {

      this.mvMatrix = mat4.create();
      this.pMatrix = mat4.create();
      this.mvMatrixStack = [];
      this.canvas = this.canvas = document.createElement("canvas");
      this.canvas.width = options.clientWidth
      this.canvas.height = options.clientHeight
      this.canvas.style.backgroundColor = "rgb(0,0,0)"
      options.appendChild(this.canvas);
      this.initGL();
      this.initShaders();
      this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
    return;
  }

  /* initialize the webgl context in the canvas */


  WebGL.prototype.initGL = function() {
    try {
      this.gl = this.canvas.getContext("experimental-webgl");
      this.gl.viewportWidth = this.canvas.width;
      this.gl.viewportHeight = this.canvas.height;
    } catch (e) {
      if (!this.gl) {
        return alert("Could not initialize WebGL, sorry :-(");
      }
    }
  };

  /* initialize shaders programs*/
  WebGL.prototype.getShader = function(url_page, type) {
    var shader, source,
      _this = this;
    source = null;
    shader = null;
      $.ajax({
          async: false,
          url: url_page,
          success: function(data) {
              source = $(data).html();
              shader = _this.gl.createShader(type);
          },
          dataType: 'html'
      });

    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      alert("shaders!");
      alert(this.gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  };

  WebGL.prototype.initShaders = function() {
    var fragmentShader, vertexShader;
    fragmentShader = this.getShader("./lib/skyview/shaders/sphere.fs", this.gl.FRAGMENT_SHADER);
    vertexShader = this.getShader("./lib/skyview/shaders/sphere.vs", this.gl.VERTEX_SHADER);
    this.shaderProgram = this.gl.createProgram();
    this.gl.attachShader(this.shaderProgram, vertexShader);
    this.gl.attachShader(this.shaderProgram, fragmentShader);
    this.gl.linkProgram(this.shaderProgram);
    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }
    this.gl.useProgram(this.shaderProgram);
    this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
    this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
    this.shaderProgram.textureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
    this.gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
    this.shaderProgram.survey = this.gl.getUniformLocation(this.shaderProgram, "uSurvey");
    this.shaderProgram.pMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uPMatrix");
    this.shaderProgram.mvMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
    this.shaderProgram.nMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uNMatrix");
    this.shaderProgram.samplerUniform = this.gl.getUniformLocation(this.shaderProgram, "uSampler");
    this.shaderProgram.alphaUniform = this.gl.getUniformLocation(this.shaderProgram, "alpha");
  };

  WebGL.prototype.getMatrices = function() {
    return [this.mvMatrix, this.pMatrix, [0, 0, this.gl.viewportWidth, this.gl.viewportHeight]];
  };

  WebGL.prototype.mvPushMatrix = function() {
    var copy;
    copy = mat4.create();
    mat4.set(this.mvMatrix, copy);
    this.mvMatrixStack.push(copy);
  };

  WebGL.prototype.mvPopMatrix = function() {
    if (this.mvMatrixStack.length === 0) {
      throw "Invalid popMatrix!";
    }
    this.mvMatrix = this.mvMatrixStack.pop();
  };

  WebGL.prototype.setMatrixUniforms = function() {
    this.gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);
  };

  WebGL.prototype.setTransforms = function(translation, rotation) {
	
      mat4.identity(this.mvMatrix);
      
      mat4.translate(this.mvMatrix, translation);
      mat4.rotate(this.mvMatrix, this.degToRad(rotation[0]), [1, 0, 0]);
      mat4.rotate(this.mvMatrix, this.degToRad(rotation[1]), [0, 1, 0]);
      mat4.rotate(this.mvMatrix, this.degToRad(rotation[2]), [0, 0, 1]);
      this.setMatrixUniforms();

  };

  WebGL.prototype.degToRad = function(deg) {
    return deg * Math.PI / 180.0;
  };

  return WebGL;

})();
