// Generated by CoffeeScript 1.3.3
var math,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

math = (function() {

  function math() {
    this.radecToImageXY = __bind(this.radecToImageXY, this);

    this.rotate = __bind(this.rotate, this);

    this.arg = __bind(this.arg, this);

    this.RGBAtoHEX = __bind(this.RGBAtoHEX, this);

    this.intersectTri = __bind(this.intersectTri, this);

    this.compare = __bind(this.compare, this);

    this.multiply = __bind(this.multiply, this);

    this.sign = __bind(this.sign, this);

    this.cross = __bind(this.cross, this);

    this.dot = __bind(this.dot, this);

    this.add = __bind(this.add, this);

    this.mult = __bind(this.mult, this);

    this.subtract = __bind(this.subtract, this);

    this.norm = __bind(this.norm, this);

    this.magnitude = __bind(this.magnitude, this);
     

    this.max = __bind(this.max, this);
    this.min = __bind(this.min, this);
  }

  math.prototype.magnitude = function(v1, v2) {
    return Math.pow(Math.pow(v1[0] + v2[0], 2) + Math.pow(v1[1] + v2[1], 2) + Math.pow(v1[2] + v2[2], 2), 0.5);
  };

  math.prototype.norm = function(v1) {
    var mag;
    mag = Math.sqrt(Math.pow(v1[0], 2) + Math.pow(v1[1], 2) + Math.pow(v1[2], 2) + 1);
    return [v1[0] / mag, v1[1] / mag, v1[2] / mag];
  };

  math.prototype.subtract = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
    } else if (v1.length === 4) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2], v1[3] - v2[3]];
    }
  };

  math.prototype.mult = function(v1, scale) {
    if (v1.length === 2) {
      return [v1[0] * scale, v1[1] * scale];
    } else if (v1.length === 3) {
      return [v1[0] * scale, v1[1] * scale, v1[2] * scale];
    } else if (v1.length === 4) {
      return [v1[0] * scale, v1[1] * scale, v1[2] * scale, v1[3] * scale];
    }
  };

  math.prototype.add = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
    } else if (v1.length === 4) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3]];
    }
  };

  math.prototype.dot = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    } else if (v1.length === 3) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    } else if (v1.length === 4) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3];
    }
  };

  math.prototype.cross = function(v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
  };

  math.prototype.sign = function(a) {
    if (a > 0) {
      return 1;
    } else if (a < 0) {
      return -1;
    } else {
      return 0;
    }
  };

  math.prototype.multiply = function(a, b) {
    var c;
    c = [0, 0, 0, 0];
    c[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + b[12];
    c[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + b[13];
    c[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + b[14];
    c[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + b[15];
    return c;
  };

  math.prototype.compare = function(a, b) {
    var i, j, _i, _j, _len, _len1;
    if (a.length !== b.length) {
      return false;
    }
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      i = a[_i];
      for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
        j = b[_j];
        if (i !== j) {
          return false;
        }
      }
    }
    return true;
  };

  math.prototype.intersectTri = function(orig, dir, verts) {
    var M, a, akjb, b, betatop, blkc, c, dheg, eihf, gammatop, gfdi, jcal, t, ttop, u, v;
    a = verts[0];
    b = verts[1];
    c = verts[2];
    eihf = (a[1] - c[1]) * dir[2] - dir[1] * (a[2] - c[2]);
    gfdi = dir[0] * (a[2] - c[2]) - (a[0] - c[0]) * dir[2];
    dheg = (a[0] - c[0]) * dir[1] - (a[1] - c[1]) * dir[0];
    M = (a[0] - b[0]) * eihf + (a[1] - b[1]) * gfdi + (a[2] - b[2]) * dheg;
    akjb = (a[0] - b[0]) * (a[1] - orig[1]) - (a[0] - orig[0]) * (a[1] - b[1]);
    jcal = (a[0] - orig[0]) * (a[2] - b[2]) - (a[0] - b[0]) * (a[2] - orig[2]);
    blkc = (a[1] - b[1]) * (a[2] - orig[2]) - (a[1] - orig[1]) * (a[2] - b[2]);
    betatop = (a[0] - orig[0]) * eihf + (a[1] - orig[1]) * gfdi + (a[2] - orig[2]) * dheg;
    gammatop = dir[2] * akjb + dir[1] * jcal + dir[0] * blkc;
    ttop = (a[2] - c[2]) * akjb + (a[1] - c[1]) * jcal + (a[0] - c[0]) * blkc;
    u = betatop / M;
    v = gammatop / M;
    t = ttop / M;
    if (u < 0.0 || u > 1.0 || t >= 0) {
      return false;
    } else {
      if (v < 0.0 || u + v > 1.0) {
        return false;
      } else {
        console.log("t", t);
        console.log("u,v", u, v);
        return true;
      }
    }
    return false;
  };

  math.prototype.RGBAtoHEX = function(color) {
    var alpha, blue, green, hex, red;
    color = this.mult(color, 255);
    red = parseInt(color[0]).toString(16);
    green = parseInt(color[1]).toString(16);
    blue = parseInt(color[2]).toString(16);
    alpha = parseInt(color[3]).toString(16);
    if (red.length === 1) {
      red = "" + red + "0";
    }
    if (green.length === 1) {
      green = "" + green + "0";
    }
    if (blue.length === 1) {
      blue = "" + blue + "0";
    }
    if (alpha.length === 1) {
      alpha = "" + alpha + "0";
    }
    return hex = "#" + red + green + blue;
  };

  math.prototype.arg = function(x, y) {
    if (x > 0) {
      return Math.atan(y / x);
    } else if (x === 0 && y > 0) {
      return Math.PI / 2.0;
    } else if (x === 0 && y < 0) {
      return -Math.PI / 2.0;
    } else if (x < 0 && y >= 0) {
      return Math.PI + Math.atan(y / x);
    } else if (x < 0 && y < 0) {
      return -Math.PI + Math.atan(y / x);
    }
  };

  math.prototype.rotate = function(x) {
    return [x[1], x[0]];
  };

  math.prototype.radecToImageXY = function(ra, dec) {
    var cosPhi, cosTheta, phi, sinPhi, sinTheta, theta, x, y, z;
    phi = (90 - dec) * Math.PI / 180.0;
    theta = 0;
    if (ra > 270) {
      theta = (270 - ra + 360) * Math.PI / 180.0;
    } else {
      theta = (270 - ra) * Math.PI / 180.0;
    }
    sinTheta = Math.sin(theta);
    cosTheta = Math.cos(theta);
    sinPhi = Math.sin(phi);
    cosPhi = Math.cos(phi);
    z = sinPhi * sinTheta;
    y = cosPhi;
    x = sinPhi * cosTheta;
    return [x, y];
  };

  math.prototype.xyToRaDec = function(xpix,ypix,parms) {
  	var x,y, ra, dec, rtod, dtor, lon, lat, decpole, l, latpole, lonpole; 
  	var lp, m, mat, mp, n, np, phi, r11, r12, r13, r21, r22, r23, r31, r32, r33;
  	var rapole, theta;
  	
  	rtod = 57.29577951308323;
  	dtor = 0.0174532925; 
  
  	x = parms.cd11 * (xpix - parms.crpix1) + parms.cd12 * (ypix - parms.crpix2);
  	y = parms.cd21 * (xpix - parms.crpix1) + parms.cd22 * (ypix - parms.crpix2);
  	
    lon = this.arg(-y, x);
    lat = (Math.PI / 2.0) * dtor;
    r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    if (r > 0.0) {
    	lat = Math.atan((180.0 / Math.PI) / r);
    }
    lat = Math.atan(rtod / r);
    
    //coords = this.convertradec(lon, lat, crval);
    //ra[index] = coords[0];
    //dec[index] = coords[1];  
    
    l = Math.cos(lat) * Math.cos(lon);
    m = Math.cos(lat) * Math.sin(lon);
    n = Math.sin(lat);
    phi = 0.0;
    theta = 90.0 * dtor;
    lonpole = parms.crval2 > theta * rtod ? 0.0 : 180.0 * dtor;
    latpole = 90.0 * dtor;
    rapole = parms.crval1 * dtor;
    decpole = parms.crval2 * dtor;
    r11 = -1.0 * Math.sin(rapole) * Math.sin(lonpole) - Math.cos(rapole) * Math.cos(lonpole) * Math.sin(decpole);
    r12 = Math.cos(rapole) * Math.sin(lonpole) - Math.sin(rapole) * Math.cos(lonpole) * Math.sin(decpole);
    r13 = Math.cos(lonpole) * Math.cos(decpole);
    r21 = Math.sin(rapole) * Math.cos(lonpole) - Math.cos(rapole) * Math.sin(lonpole) * Math.sin(decpole);
    r22 = -1.0 * Math.cos(rapole) * Math.cos(lonpole) - Math.sin(rapole) * Math.sin(lonpole) * Math.sin(decpole);
    r23 = Math.sin(lonpole) * Math.cos(decpole);
    r31 = Math.cos(rapole) * Math.cos(decpole);
    r32 = Math.sin(rapole) * Math.cos(decpole);
    r33 = Math.sin(decpole);
    mat = [[r11, r21, r31], [r12, r22, r32], [r13, r23, r33]];
    lp = mat[0][0] * l + mat[0][1] * m + mat[0][2] * n;
    mp = mat[1][0] * l + mat[1][1] * m + mat[1][2] * n;
    np = mat[2][0] * l + mat[2][1] * m + mat[2][2] * n;
    dec = Math.asin(np) * rtod;
    ra = Math.atan2(mp, lp) * rtod;
    if (ra < 0.0) {
      ra += 360.0;
    } else if (ra > 360.0) {
      ra -= 360;
    }    
    
  	return [ra, dec];
  
  };

  math.prototype.ToImgCoord = function(x,y,xmin,ymin,spanx,spany){
	var rowX, rowY;
	rowX = Math.abs(x-xmin) * (2048.0/spanx);
	rowY = Math.abs(y-ymin) * (2048.0/spany);
	return [rowX, rowY];
  };

  math.min = function(items){
      var min = items[0];
      for(var i = 0; i < items.length; i++){
	  if(items[i] < min){
	      min = items[i];
	  }
      }
      return min;
  }

  math.max = function(items){
      var max = items[0];
      for(var i = 0; i < items.length; i++){
	  if(items[i] > max){
	      max = items[i];
	  }
      }
      return max;      
  }
  return math;

})();
