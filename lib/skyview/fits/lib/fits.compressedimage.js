// Generated by CoffeeScript 1.3.3
(function() {
  var CompImage, Decompress, Tabular,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Tabular = require('./fits.tabular');

  Decompress = require('./fits.decompress');

  CompImage = (function(_super) {

    __extends(CompImage, _super);

    CompImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    CompImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    CompImage.extend(Decompress);

    CompImage.typedArray = {
      B: Uint8Array,
      I: Int16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint8Array,
      4: Int16Array,
      8: Int32Array
    };

    function CompImage(view, header) {
      var i, key, value, ztile, _i, _ref;
      CompImage.__super__.constructor.apply(this, arguments);
      this.length += header["PCOUNT"];
      this.zcmptype = header["ZCMPTYPE"];
      this.zbitpix = header["ZBITPIX"];
      this.znaxis = header["ZNAXIS"];
      this.zblank = CompImage.setValue(header, "ZBLANK", void 0);
      this.blank = CompImage.setValue(header, "BLANK", void 0);
      this.min = header["DATAMIN"] != null ? header["DATAMIN"] : void 0;
      this.max = header["DATAMAX"] != null ? header["DATAMAX"] : void 0;
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header["ZTILE" + i] : i === 1 ? header["ZNAXIS1"] : 1;
        this.ztile.push(ztile);
      }
      this.algorithmParameters = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.algorithmParameters[header[key]] = header[value];
        i += 1;
      }
      this["setDefaultParameters_" + this.zcmptype]();
      this.zmaskcmp = CompImage.setValue(header, "ZMASKCMP", void 0);
      this.zquantiz = CompImage.setValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = CompImage.setValue(header, "BZERO", 0);
      this.bscale = CompImage.setValue(header, "BSCALE", 1);
      this.defineColumnAccessors(header);
      this.defineGetRow();
    }

    CompImage.prototype.defineColumnAccessors = function(header) {
      var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results,
        _this = this;
      this.columnNames = {};
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        value = header["TFORM" + i];
        match = value.match(CompImage.arrayDescriptorPattern);
        ttype = header["TTYPE" + i].toUpperCase();
        this.columnNames[ttype] = i - 1;
        accessor = null;
        if (match != null) {
          dataType = match[1];
          switch (ttype) {
            case "COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, pixels;
                  data = _this._accessor(dataType);
                  if (data == null) {
                    return null;
                  }
                  pixels = new CompImage.typedArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
                  CompImage.Rice(data, length, _this.algorithmParameters["BLOCKSIZE"], _this.algorithmParameters["BYTEPIX"], pixels, _this.ztile[0]);
                  return pixels;
                };
              })(dataType);
              break;
            case "UNCOMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            case "GZIP_COMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            default:
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
          }
        } else {
          match = value.match(CompImage.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length != null ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              return accessor = function() {
                return CompImage.dataAccessors[dataType](_this.view);
              };
            })(dataType);
          } else {
            (function(length, dataType) {
              return accessor = function() {
                var data, _j, _ref2;
                data = new CompImage.typedArray[dataType](length);
                for (i = _j = 0, _ref2 = length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  data[i] = CompImage.dataAccessors[dataType](_this.view);
                }
                return data;
              };
            })(length, dataType);
          }
        }
        _results.push(this.accessors.push(accessor));
      }
      return _results;
    };

    CompImage.prototype.defineGetRow = function() {
      var hasBlanks;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompImage.prototype.setDefaultParameters_RICE_1 = function() {
      if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
        this.algorithmParameters["BLOCKSIZE"] = 32;
      }
      if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
        return this.algorithmParameters["BYTEPIX"] = 4;
      }
    };

    CompImage.setValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header[key];
      } else {
        return defaultValue;
      }
    };

    CompImage.prototype.getFrame = function() {
      var index, location, row, value, _i, _len;
      this.rowsRead = 0;
      this.data = new Float32Array(this.ztile[0] * this.rows);
      while (true) {
        row = this.getRow();
        for (index = _i = 0, _len = row.length; _i < _len; index = ++_i) {
          value = row[index];
          location = this.rowsRead * this.ztile[0] + index;
          this.data[this.rowsRead * this.ztile[0] + index] = value;
        }
        if (this.rowsRead === this.rows) {
          break;
        }
      }
      return this.data;
    };

    CompImage.prototype.getRowHasBlanks = function() {
      var blank, data, index, pixels, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      pixels = new Float32Array(data.length);
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        if (value === blank) {
          pixels[index] = NaN;
          continue;
        }
        pixels[index] = zero + (scale * value);
      }
      return pixels;
    };

    CompImage.prototype.getRowNoBlanks = function() {
      var blank, data, index, pixels, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      pixels = new Float32Array(data.length);
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        pixels[index] = zero + scale * value;
      }
      return pixels;
    };

    CompImage.prototype._accessor = function(dataType) {
      var data, i, length, offset, _i, _ref, _ref1;
      _ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
      if (length === 0) {
        return null;
      }
      data = new CompImage.typedArray[dataType](length);
      this.current = this.view.tell();
      this.view.seek(this.begin + this.tableLength + offset);
      for (i = _i = 0, _ref1 = length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        data[i] = CompImage.dataAccessors[dataType](this.view);
      }
      this.view.seek(this.current);
      return data;
    };

    CompImage.prototype._getRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      this.rowsRead += 1;
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompImage.prototype.getExtremes = function() {
      var i, index, max, min, value, _i, _j, _len, _ref, _ref1, _ref2, _ref3;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      _ref = this.data;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        value = _ref[index];
        if (isNaN(value)) {
          continue;
        }
        _ref1 = [value, value], min = _ref1[0], max = _ref1[1];
        break;
      }
      for (i = _j = index, _ref2 = this.data.length - 1; index <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = index <= _ref2 ? ++_j : --_j) {
        value = this.data[i];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref3 = [min, max], this.min = _ref3[0], this.max = _ref3[1];
      return [this.min, this.max];
    };

    CompImage.subtractiveDither1 = function() {
      throw "Not yet implemented";
    };

    CompImage.linearScaling = function() {
      throw "Not yet implemented";
    };

    return CompImage;

  })(Tabular);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = CompImage;
  }

}).call(this);
