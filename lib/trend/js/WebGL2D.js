// Generated by CoffeeScript 1.4.0
var WebGL,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

WebGL = (function() {

  WebGL.gl = 0;

  WebGL.shaderProgram = 0;

  WebGL.mvMatrix = 0;

  WebGL.mvMatrixStack = null;

  WebGL.pMatrix = 0;

  function WebGL(options) {
    this.render = __bind(this.render, this);

    this.handleLoadedTexture = __bind(this.handleLoadedTexture, this);

    this.copyImage = __bind(this.copyImage, this);

    this.bindPos = __bind(this.bindPos, this);

    this.degToRad = __bind(this.degToRad, this);

    this.initShaders = __bind(this.initShaders, this);

    this.getShader = __bind(this.getShader, this);

    this.getContext = __bind(this.getContext, this);

    this.initGL = __bind(this.initGL, this);

    this.logAndValidate = __bind(this.logAndValidate, this);

    this.validateNoneOfTheArgsAreUndefined = __bind(this.validateNoneOfTheArgsAreUndefined, this);

    this.logGLCalls = __bind(this.logGLCalls, this);

    var _this = this;
	//console.log(options.canvas)	;
    this.canvas = options.canvas != null ? options.canvas : (this.canvas = document.createElement("glCanvas"), this.canvas.width = options.clientWidth, this.canvas.height = options.clientHeight, this.canvas.style.backgroundColor = "rgb(0,0,0)", options.appendChild(this.canvas));
    this.initGL();
    this.initShaders();
    this.texture = this.gl.createTexture();
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
    return;
    ({
      throwOnGLError: function(err, funcName, args) {
        throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
      }
    });
  }

  WebGL.prototype.logGLCalls = function(functionName, args) {
    console.log("gl." + functionName + "(" + WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
  };

  WebGL.prototype.validateNoneOfTheArgsAreUndefined = function(functionName, args) {
    var ii, _i, _ref;
    for (ii = _i = 0, _ref = args.length; 0 <= _ref ? _i <= _ref : _i >= _ref; ii = 0 <= _ref ? ++_i : --_i) {
      if (args[ii] === "undefined") {
        console.error("undefined passed to gl." + functionName + "(" + WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
      }
    }
  };

  WebGL.prototype.logAndValidate = function(functionName, args) {
    this.logGLCalls(functionName, args);
    this.validateNoneOfTheArgsAreUndefined(functionName, args);
  };

  /* initialize the webgl context in the canvas
  */


  WebGL.prototype.initGL = function() {
    try {
      return this.gl = this.canvas.getContext("experimental-webgl");
    } catch (e) {
      if (!this.gl) {
        alert("Could not initialize WebGL, sorry :-(");
        return console.log(e);
      }
    }
  };

  WebGL.prototype.getContext = function() {
    return {
      gl: this.gl,
      shader: this.shaderProgram
    };
  };

  /* initialize shaders programs
  */


  WebGL.prototype.getShader = function(id, name) {
    var shader, source,
      _this = this;
    source = null;
    shader = null;
    if (id === "vertex") {
      $.ajax({
        async: false,
        url: "lib/trend/shaders/" + name,
        success: function(data) {
          source = $(data).html();
	  //console.log(source);
          shader = _this.gl.createShader(_this.gl.VERTEX_SHADER);
        },
        dataType: 'html'
      });
    } else {
      $.ajax({
        async: false,
        url: "lib/trend/shaders/" + name,
        success: function(data) {
          source = $(data).html();
	  //console.log(source);
          shader = _this.gl.createShader(_this.gl.FRAGMENT_SHADER);
        },
        dataType: 'html'
      });
    }
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      alert("shaders are malfunctioning!");
      alert(this.gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  };

  WebGL.prototype.initShaders = function() {
    var fragmentShader, vertexShader;
    fragmentShader = this.getShader("fragment", "fisheye.fs");
    vertexShader = this.getShader("vertex", "vertex.vs");
    this.shaderProgram = this.gl.createProgram();
    this.gl.attachShader(this.shaderProgram, vertexShader);
    this.gl.attachShader(this.shaderProgram, fragmentShader);
    this.gl.linkProgram(this.shaderProgram);
    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }
    this.gl.useProgram(this.shaderProgram);
    this.shaderProgram.samplerUniform = this.gl.getUniformLocation(this.shaderProgram, "trendImage");
    this.shaderProgram.texUniform = this.gl.getUniformLocation(this.shaderProgram, "uTexSize");
    this.shaderProgram.mouseUniform = this.gl.getUniformLocation(this.shaderProgram, "iMouse");
    this.shaderProgram.resUniform = this.gl.getUniformLocation(this.shaderProgram, "u_Res");
    this.shaderProgram.lensUniform = this.gl.getUniformLocation(this.shaderProgram, "lens");
    this.shaderProgram.positionCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aPositionCoord");
    this.gl.enableVertexAttribArray(this.shaderProgram.positionCoordAttribute);
    this.shaderProgram.textureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
    this.gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
    this.gl.uniform2f(this.shaderProgram.resUniform, this.canvas.width, this.canvas.height);
    this.gl.uniform2f(this.shaderProgram.texUniform, this.canvas.width, this.canvas.height);
  };

  WebGL.prototype.degToRad = function(deg) {
    return deg * Math.PI / 180.0;
  };

  WebGL.prototype.bindPos = function() {
    var pos, x1, x2, y1, y2;
    pos = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, pos);
    x1 = 0;
    x2 = 0 + this.canvas.width;
    y1 = 0;
    y2 = 0 + this.canvas.height;
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this.gl.STATIC_DRAW);
    this.gl.vertexAttribPointer(this.shaderProgram.positionCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
  };

  WebGL.prototype.copyImage = function(src) {
    var _this = this;
    this.gl.viewportWidth = this.canvas.width;
    this.gl.viewportHeight = this.canvas.height;
    this.texture.image = new Image();
    this.texture.image.onload = function() {
      _this.handleLoadedTexture(_this.texture);
      _this.render();
    };
    this.texture.image.src = src;
    return this.texture;
  };

  WebGL.prototype.handleLoadedTexture = function(texture) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, texture.image);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
  };

  WebGL.prototype.render = function() {
    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
  };

  return WebGL;

})();
